from typing import Any, Text, Dict, List
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from rasa_sdk.forms import FormValidationAction
from rasa_sdk.types import DomainDict
from rasa_sdk.events import SlotSet
from datetime import datetime, timedelta
from dateutil.parser import parse
import re
import logging
import dateparser as dt

from .gemini_integration import GeminiIntegration

logger = logging.getLogger(__name__)

class ActionAnalyzeSymptoms(Action):
    def name(self) -> Text:
        return "action_analyze_symptoms"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        symptoms = tracker.get_slot("symptoms") or []
        
        logger.info(f"Analisando sintomas: {symptoms}")

        if not symptoms:
            entities = tracker.latest_message.get("entities", [])
            symptoms = [e.get("value") for e in entities if e.get("entity") == "symptom"]
        
        # ValidaÃ§Ã£o inicial
        if not symptoms:
            dispatcher.utter_message(text="NÃ£o consegui identificar sintomas especÃ­ficos. Pode descrevÃª-los novamente?")
            return []
        
        try:
            # Sua integraÃ§Ã£o com Gemini
            gemini = GeminiIntegration()
            analysis = gemini.analyze_symptoms(symptoms)
            
            # ValidaÃ§Ã£o da resposta do Gemini
            if not analysis or not analysis.get('specialty'):
                raise ValueError("Gemini retornou anÃ¡lise invÃ¡lida ou vazia")
            
            # Verificar se tem erro na resposta
            if analysis.get('specialty', '').lower() in ['indefinida', 'erro', 'error', '']:
                raise ValueError(f"Gemini retornou specialty invÃ¡lida: {analysis.get('specialty')}")
            
            # Mapear mensagens de urgÃªncia
            urgency_messages = {
                "emergÃªncia": "âš  ATENÃ‡ÃƒO: Seus sintomas podem indicar urgÃªncia mÃ©dica. Procure atendimento imediato!",
                "alta": "âš  Recomendamos buscar atendimento mÃ©dico hoje mesmo.",
                "mÃ©dia": "Recomendamos agendar consulta nos prÃ³ximos dias.",
                "baixa": "VocÃª pode agendar uma consulta de rotina."
            }
            
            # Montar mensagem de resposta
            message = f"""
                AnÃ¡lise dos seus sintomas:

                ðŸ”¹ *Especialidade recomendada:* {analysis['specialty']}
                ðŸ”¹ *UrgÃªncia:* {analysis['urgency']}
                ðŸ”¹ *OrientaÃ§Ã£o:* {analysis['explanation']}

                {urgency_messages.get(analysis['urgency'], '')}
            """
            
            if analysis.get('immediate_care'):
                message += f"\n\n*Cuidados imediatos:* {analysis['immediate_care']}"
            
            dispatcher.utter_message(text=message)
            
            return [
                SlotSet("recommended_specialty", analysis['specialty']),
                SlotSet("specialty", analysis['specialty']),
                SlotSet("symptoms_urgency", analysis['urgency']),
                SlotSet("symptoms_explanation", analysis['explanation'])
            ]
            
        except Exception as e:
            # Log detalhado do erro para debug
            logger.error(f"ERRO na anÃ¡lise Gemini: {str(e)}")
            logger.error(f"Sintomas recebidos: {symptoms}")
            logger.error(f"Tipo do erro: {type(e)._name_}")
            
            # Resposta de fallback amigÃ¡vel que mantÃ©m o fluxo
            symptoms_text = ', '.join(symptoms) if isinstance(symptoms, list) else str(symptoms)
            
            dispatcher.utter_message(text=f"""
                Entendi que vocÃª tem: {symptoms_text}

                No momento estou com dificuldades tÃ©cnicas para fazer a anÃ¡lise automÃ¡tica. 
                Vamos agendar uma consulta com um *ClÃ­nico Geral* que poderÃ¡ avaliar adequadamente seus sintomas.

                Posso prosseguir com o agendamento?
            """)
            
            # Retorna slots vÃ¡lidos mesmo com erro - NÃƒO quebra o fluxo
            return [
                SlotSet("recommended_specialty", "ClÃ­nico Geral"),
                SlotSet("specialty", "ClÃ­nico Geral"),
                SlotSet("symptoms_urgency", "mÃ©dia"),
                SlotSet("symptoms_explanation", "Consulta recomendada devido a indisponibilidade temporÃ¡ria da anÃ¡lise automÃ¡tica.")
            ]

class ValidateAppointmentForm(FormValidationAction):
    def name(self) -> Text:
        return "validate_appointment_form"

    def validate_patient_name(
        self,
        slot_value: Any,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: DomainDict,
    ) -> Dict[Text, Any]:
        
        if slot_value and len(slot_value) >= 2:
            return {"patient_name": slot_value}
        else:
            dispatcher.utter_message(text="Por favor, informe um nome vÃ¡lido.")
            return {"patient_name": None}

    def validate_patient_email(
        self,
        slot_value: Any,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: DomainDict,
    ) -> Dict[Text, Any]:

        # ExpressÃ£o regular simples para validar e-mail
        email_pattern = r"[^@]+@[^@]+\.[^@]+"

        if slot_value and re.match(email_pattern, slot_value):
            return {"patient_email": slot_value}
        
        dispatcher.utter_message(text="Por favor, informe um e-mail vÃ¡lido (ex: nome@exemplo.com).")
        return {"patient_email": None}

    def validate_appointment_date(
        self,
        slot_value: Any,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: DomainDict,
    ) -> Dict[Text, Any]:
        
        try:
            # Tenta converter qualquer formato para datetime.date
            date_obj = dt.parse(slot_value, languages=["pt"], settings={"PREFER_DATES_FROM": "future"})

            if date_obj >= datetime.now().date():
                # Retorna data no formato brasileiro
                return {"appointment_date": date_obj.strftime("%d/%m/%Y")}
            else:
                dispatcher.utter_message(text="A data deve ser hoje ou no futuro.")
                return {"appointment_date": None}

        except Exception:
            dispatcher.utter_message(text="Por favor, informe a data no formato DD/MM/AAAA.")
            return {"appointment_date": None}


    def validate_appointment_time(
        self,
        slot_value: Any,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: DomainDict,
    ) -> Dict[Text, Any]:
        
        if slot_value:
            try:
                # Verifica formato HH:MM
                time_obj = datetime.strptime(slot_value, "%H:%M")
                hour = time_obj.hour
                
                # Verifica horÃ¡rio comercial (8h Ã s 18h)
                if 8 <= hour <= 18:
                    return {"appointment_time": slot_value}
                else:
                    dispatcher.utter_message(text="HorÃ¡rio deve estar entre 08:00 e 18:00.")
                    return {"appointment_time": None}
            except ValueError:
                dispatcher.utter_message(text="Por favor, informe o horÃ¡rio no formato HH:MM (ex: 14:30).")
                return {"appointment_time": None}
        
        return {"appointment_time": None}
    
    def validate_specialty(
            self,
            slot_value: Any, 
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:  

        if tracker.get_slot("recommended_specialty"):
            specialty = tracker.get_slot("recommended_specialty")

        especialidades = {"clÃ­nica geral": "ClÃ­nica Geral",
                "clÃ­nico geral": "ClÃ­nica Geral",
                "clinica geral": "ClÃ­nica Geral",
                "clinico geral": "ClÃ­nica Geral",
                "pediatria": "Pediatria",
                "cardiologia": "Cardiologia",
                "dermatologia": "Dermatologia"
            }
        if specialty:
            if specialty.lower() in especialidades:
                return {"specialty": especialidades[specialty.lower()]}
            else:
                dispatcher.utter_message(text=f"Desculpe, nÃ£o temos a especialidade {specialty} no nosso consultÃ³rio."
                                         "Trabalhamos com: ClÃ­nica Geral, Pediatria, Cardiologia e Dermatologia"
                                         "Qual dessas vocÃª gostaria?")
                return {"specialty": None}
        else: 
            return {"specialty": None}

class ActionScheduleAppointment(Action):
    def name(self) -> Text:
        return "action_schedule_appointment"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        # Coleta dados do agendamento
        patient_data = {
            'name': tracker.get_slot("patient_name"),
            'phone': tracker.get_slot("patient_phone"),
            'symptoms': tracker.get_slot("symptoms") or [],
            'specialty': tracker.get_slot("specialty") or tracker.get_slot("recommended_specialty"),
            'date': tracker.get_slot("appointment_date"),
            'time': tracker.get_slot("appointment_time")
        }
        
        confirmation_message = f"""
            âœ… **Consulta Agendada com Sucesso!**

            ðŸ“‹ **Detalhes:**
            - **Paciente:** {patient_data['name']}
            - **Especialidade:** {patient_data['specialty']}
            - **Data:** {patient_data['date']}
            - **HorÃ¡rio:** {patient_data['time']}
            - **Telefone:** {patient_data['phone']}

            ðŸ“± **PrÃ³ximos passos:**
            1. VocÃª receberÃ¡ SMS de confirmaÃ§Ã£o
            2. Chegue 15 minutos antes do horÃ¡rio
            3. Traga documentos e exames anteriores

            HÃ¡ algo a mais que eu possa ajudar?
        """
        
        dispatcher.utter_message(text=confirmation_message)
        
        return []
    
class ActionHandleFormInterruption(Action):
    def name(self) -> Text:
        return "action_handle_form_interruption"

    def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        dispatcher.utter_message(text="Ok, entendi. Cancelei o preenchimento do formulÃ¡rio."
                                 "HÃ¡ algo a mais que eu possa ajudar?")

        # Desativa o formulÃ¡rio explicitamente
        # VocÃª precisa saber o nome do formulÃ¡rio que estÃ¡ ativo, ex: 'appointment_form'
        return [SlotSet("requested_slot", None), SlotSet("active_loop", None)]
        # ActiveLoopSet(None) desativa qualquer loop ativo.
        # SlotSet("requested_slot", None) limpa o slot que o formulÃ¡rio estava pedindo.